I am solving optimization problems using evolutionary algorithms. 
The goal is to design crossover solvers that take two parent solutions and produce one offspring solution. 

I have 5 existing solvers with their codes as follows:
No.1 solver’s description, its corresponding code are:
# Its Description
{Simulated Binary Crossover (SBX): This operator generates offspring by simulating the effect of single-point crossover on real-coded variables, controlled by a distribution index parameter.}
# Its Python Code Implementation of a Function
import numpy as np
def crossover(parent1, parent2, eta=20):
    dim = len(parent1)
    offspring = np.zeros(dim)
    for i in range(dim):
        u = np.random.rand()
        if u <= 0.5:
            beta = (2*u)**(1/(eta+1))
        else:
            beta = (1/(2*(1-u)))**(1/(eta+1))
        offspring[i] = 0.5*((1+beta)*parent1[i] + (1-beta)*parent2[i])
        offspring[i] = np.clip(offspring[i], 0.0, 1.0)
    return offspring

No.2 solver’s description, its corresponding code are:
# Its Description
{Arithmetic Crossover: This operator creates an offspring as a weighted average of two parents, ensuring smooth blending of their traits.}
# Its Python Code Implementation of a Function
import numpy as np
def crossover(parent1, parent2, alpha=None):
    if alpha is None:
        alpha = np.random.rand()
    offspring = alpha * parent1 + (1 - alpha) * parent2
    offspring = np.clip(offspring, 0.0, 1.0)
    return offspring

No.3 solver’s description, its corresponding code are:
# Its Description
{Differential Evolution (DE) Crossover: This operator generates an offspring by adding a weighted difference between two parents to one of them, followed by binomial crossover.}
# Its Python Code Implementation of a Function
import numpy as np
def crossover(parent1, parent2, F=0.5, CR=0.9):
    dim = len(parent1)
    offspring = np.copy(parent1)
    j_rand = np.random.randint(dim)
    for j in range(dim):
        if np.random.rand() < CR or j == j_rand:
            offspring[j] = parent1[j] + F * (parent2[j] - parent1[j])
        offspring[j] = np.clip(offspring[j], 0.0, 1.0)
    return offspring

No.4 solver’s description, its corresponding code are:
# Its Description
{Uniform Crossover: This operator generates an offspring by randomly choosing each gene from either parent with equal probability.}
# Its Python Code Implementation of a Function
import numpy as np
def crossover(parent1, parent2):
    dim = len(parent1)
    mask = np.random.rand(dim) < 0.5
    offspring = np.where(mask, parent1, parent2)
    offspring = np.clip(offspring, 0.0, 1.0)
    return offspring

No.5 solver’s description, its corresponding code are:
# Its Description
{Blend Crossover (BLX-α): This operator generates an offspring by sampling each gene from a uniform interval extended beyond the range of the two parents, controlled by parameter α.}
# Its Python Code Implementation of a Function
import numpy as np
def crossover(parent1, parent2, alpha=0.5):
    dim = len(parent1)
    offspring = np.zeros(dim)
    for i in range(dim):
        cmin = min(parent1[i], parent2[i])
        cmax = max(parent1[i], parent2[i])
        I = cmax - cmin
        lower = cmin - alpha * I
        upper = cmax + alpha * I
        offspring[i] = np.random.uniform(lower, upper)
        offspring[i] = np.clip(offspring[i], 0.0, 1.0)
    return offspring

Please create a new solver that has a totally different form from the given solvers. 
Try generating code with different structures, flows, or operators. 
The new solver should aim for strong performance on optimization tasks.

First, describe the design idea and main steps of your solver in one sentence. 
The description must be inside a brace outside the code implementation. 
Next, implement it in Python as a function named `crossover`.

This function should accept 2 inputs: `parent1` and `parent2`, both real-valued vectors. 
The function should return 1 output: `offspring`, a real-valued vector. 
The offspring must stay within the bounds [0, 1] for each variable. 

Do not give additional explanations.