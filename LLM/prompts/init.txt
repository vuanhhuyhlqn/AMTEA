I am solving optimization problems using evolutionary algorithms. 
The goal is to design generation solvers that take a population of parent solutions and produce an offspring population. 

I have 2 existing solvers with their codes as follows:
No.1 solver’s description, its corresponding code are:
# Its Description
{Simulated Binary Crossover (SBX) combined with Polynomial Mutation: This operator generates an offspring population by pairing parents from the given population, performing SBX crossover on each pair, and then applying polynomial mutation to introduce additional diversity.}
# Its Python Code Implementation of a Function
import numpy as np
def generation(population, eta_c=20, eta_m=15, pm=0.1):
    N, d = population.shape
    offspring = np.zeros_like(population)
    indices = np.random.permutation(N)
    half = N // 2

    for i in range(half):
        p1 = population[indices[i]]
        p2 = population[indices[i + half]]
        child = np.empty(d)
        # SBX crossover
        for j in range(d):
            u = np.random.rand()
            if u <= 0.5:
                beta = (2 * u) ** (1 / (eta_c + 1))
            else:
                beta = (1 / (2 * (1 - u))) ** (1 / (eta_c + 1))
            child[j] = 0.5 * ((1 + beta) * p1[j] + (1 - beta) * p2[j])
        # polynomial mutation
        for j in range(d):
            if np.random.rand() < pm:
                u = np.random.rand()
                if u < 0.5:
                    delta = (2 * u) ** (1 / (eta_m + 1)) - 1
                else:
                    delta = 1 - (2 * (1 - u)) ** (1 / (eta_m + 1))
                child[j] += delta
        offspring[i] = np.clip(child, 0.0, 1.0)

    if N % 2 != 0:
        offspring[-1] = population[indices[-1]]
    return offspring

No.2 solver’s description, its corresponding code are:
# Its Description
{Differential Evolution (DE) Crossover: This operator generates an offspring population by applying DE/rand/1 mutation and binomial crossover to each individual in the given population.}
# Its Python Code Implementation of a Function
import numpy as np
def generation(population, F=0.5, CR=0.9):
    N, d = population.shape
    offspring = np.zeros_like(population)

    for i in range(N):
        idxs = np.random.choice([idx for idx in range(N) if idx != i], 3, replace=False)
        x1, x2, x3 = population[idxs]
        trial = population[i].copy()
        j_rand = np.random.randint(d)
        for j in range(d):
            if np.random.rand() < CR or j == j_rand:
                trial[j] = x1[j] + F * (x2[j] - x3[j])
        offspring[i] = np.clip(trial, 0.0, 1.0)
    return offspring

Important requirement: The new solver you generate must not replicate or trivially modify any of the above implementations. Instead, you should:
combine, hybridize, or extend ideas from the existing solvers in novel ways, or invent a completely new crossover strategy inspired by them, but with a different mechanism, structure, or flow.
You can use stochastic elements, adapt parameters from parents, multi-point operations, self-adaptive weights, or hierarchical procedures.

The new solver should aim for strong performance on optimization tasks.
First, describe the design idea and main steps of your solver in one sentence. 
The description must be inside a brace outside the code implementation. 
Next, implement it in Python as a function named `generation`.

This function should accept only 1 input: `population`, an array of shape (N, d) of real-valued vectors. 
The function should return 1 output: `offspring`, an array of shape (N, d) of real-valued vectors. 
The offspring must stay within the bounds [0, 1] for each variable. 

Do not give additional explanations.
