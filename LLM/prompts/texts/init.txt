I am solving optimization problems using evolutionary algorithms. 
The goal is to design generation solvers that take a population of parent solutions and produce an offspring population. 

I have 2 existing solvers with their codes as follows:
No.1 solver’s description, its corresponding code are:
# Its Description
{Simulated Binary Crossover (SBX) combined with Polynomial Mutation: This operator generates an offspring population by pairing parents from the given population, performing SBX crossover on each pair, and then applying polynomial mutation to introduce additional diversity.}
# Its Python Code Implementation of a Function
import numpy as np
def ga_crossover(par_dec1: np.ndarray, par_dec2: np.ndarray, mu: float):
    D = par_dec1.shape[0]
    u = np.random.rand(D)
    beta = np.zeros(D)
    beta[u <= 0.5] = (2 * u[u <= 0.5]) ** (1.0 / (mu + 1))
    beta[u > 0.5] = (2 * (1 - u[u > 0.5])) ** (-1.0 / (mu + 1))

    # flip sign randomly
    beta = beta * ((-1) ** np.random.randint(0, 2, size=D))
    beta[np.random.rand(D) < 0.5] = 1.0

    off1 = 0.5 * ((1 + beta) * par_dec1 + (1 - beta) * par_dec2)
    off2 = 0.5 * ((1 + beta) * par_dec2 + (1 - beta) * par_dec1)
    return off1, off2

def ga_mutation(dec: np.ndarray, mu: float, prob_m: float = None):
    D = dec.shape[0]
    if prob_m is None:
        prob_m = 1.0 / D
    dec = dec.copy()
    for d in range(D):
        if np.random.rand() < prob_m:
            u = np.random.rand()
            if u <= 0.5:
                delta = ( (2 * u + (1 - 2 * u) * (1 - dec[d]) ** (mu + 1)) ** (1.0 / (mu + 1)) ) - 1.0
                dec[d] += delta
            else:
                delta = 1.0 - ( (2 * (1 - u) + 2 * (u - 0.5) * dec[d] ** (mu + 1)) ** (1.0 / (mu + 1)) )
                dec[d] += delta
    return dec

def generation(population: np.ndarray, mu_c: float = 20, mu_m: float = 15):
    N, d = population.shape
    if N <= 1:
        return np.array([ga_mutation(population[0], mu_m) for _ in range(N)])

    indorder = np.random.permutation(N)
    offspring = np.zeros_like(population)
    count = 0
    half = int(np.ceil(N / 2))
    for i in range(half):
        p1 = indorder[i]
        p2 = indorder[i + (N // 2) % N] 
        off1 = population[p1].copy()
        off2 = population[p2].copy()

        # SBX crossover
        off1, off2 = ga_crossover(population[p1], population[p2], mu_c)

        # mutation
        off1 = ga_mutation(off1, mu_m)
        off2 = ga_mutation(off2, mu_m)

        off1 = np.clip(off1, 0.0, 1.0)
        off2 = np.clip(off2, 0.0, 1.0)

        offspring[count] = off1
        if count + 1 < N:
            offspring[count + 1] = off2
        count += 2
    return offspring

No.2 solver’s description, its corresponding code are:
# Its Description
{Differential Evolution (DE) Crossover: This operator generates an offspring population by applying DE/rand/1 mutation and binomial crossover to each individual in the given population.}
# Its Python Code Implementation of a Function
import numpy as np
def de_crossover(off_dec: np.ndarray, par_dec: np.ndarray, CR: float):
    D = off_dec.shape[0]
    replace = np.random.rand(D) > CR
    j_rand = np.random.randint(D)
    replace[j_rand] = False
    off_dec = off_dec.copy()
    off_dec[replace] = par_dec[replace]
    return off_dec

def ga_mutation(dec: np.ndarray, mu: float, prob_m: float = None):
    D = dec.shape[0]
    if prob_m is None:
        prob_m = 1.0 / D
    dec = dec.copy()
    for d in range(D):
        if np.random.rand() < prob_m:
            u = np.random.rand()
            if u <= 0.5:
                delta = ( (2 * u + (1 - 2 * u) * (1 - dec[d]) ** (mu + 1)) ** (1.0 / (mu + 1)) ) - 1.0
                dec[d] += delta
            else:
                delta = 1.0 - ( (2 * (1 - u) + 2 * (u - 0.5) * dec[d] ** (mu + 1)) ** (1.0 / (mu + 1)) )
                dec[d] += delta
    return dec

def generation(population: np.ndarray, F: float = 0.5, CR: float = 0.9, mu_m: float = 15.0):
    N, d = population.shape
    offspring = np.zeros_like(population)

    if N < 4:
        for i in range(N):
            offspring[i] = ga_mutation(population[i], mu_m)
        return np.clip(offspring, 0.0, 1.0)

    for i in range(N):
        idxs = np.random.choice([idx for idx in range(N) if idx != i], 3, replace=False)
        x1, x2, x3 = population[idxs]

        # mutation: x1 + F*(x2-x3)
        trial = x1 + F * (x2 - x3)

        trial = de_crossover(trial, population[i], CR)

        offspring[i] = np.clip(trial, 0.0, 1.0)

    return offspring

Important requirement: 
- Implement the new solver in Python in a single code block suitable for a file named `solver.py`.
- It is allowed and recommended to define multiple helper functions (for example custom crossover, mutation, parameter adaptation…) inside the same code block.
- The main entry point must be a function named `generation(population: np.ndarray)` which returns an array of shape (N,d) with offspring values in [0,1].
- Do not replicate or trivially modify the two above implementations. Combine, hybridize, or extend ideas in a novel way (for example adaptive parameters, multi-point operations, hierarchical selection).

First, describe the design idea and main steps of your solver in one sentence inside curly braces outside the code implementation.
Then implement the full Python code (helper functions + main `generation`) in one code block.

Do not give additional explanations.
