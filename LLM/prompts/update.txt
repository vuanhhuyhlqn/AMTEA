I am solving optimization problems using evolutionary algorithms.
The goal is to design generation solvers that take a population of parent solutions and produce an offspring population.

I have a list of well-performing solvers with their descriptions and Python code implementations as follows:

**Good solvers:**

No.1 solver’s description and its code:
# Its Description
{Simulated Binary Crossover (SBX) combined with Polynomial Mutation: This operator generates an offspring population by pairing parents from the given population, performing SBX crossover on each pair, and then applying polynomial mutation to introduce additional diversity.}
# Its Python Code Implementation of a Function
import numpy as np

def ga_crossover(par_dec1: np.ndarray, par_dec2: np.ndarray, mu: float):
    """
    SBX crossover giống GA_Crossover trong MATLAB gốc.
    """
    D = par_dec1.shape[0]
    u = np.random.rand(D)
    beta = np.zeros(D)
    beta[u <= 0.5] = (2 * u[u <= 0.5]) ** (1.0 / (mu + 1))
    beta[u > 0.5] = (2 * (1 - u[u > 0.5])) ** (-1.0 / (mu + 1))

    # flip sign randomly
    beta = beta * ((-1) ** np.random.randint(0, 2, size=D))
    beta[np.random.rand(D) < 0.5] = 1.0

    off1 = 0.5 * ((1 + beta) * par_dec1 + (1 - beta) * par_dec2)
    off2 = 0.5 * ((1 + beta) * par_dec2 + (1 - beta) * par_dec1)
    return off1, off2

def ga_mutation(dec: np.ndarray, mu: float, prob_m: float = None):
    """
    Polynomial mutation giống GA_Mutation trong MATLAB gốc.
    """
    D = dec.shape[0]
    if prob_m is None:
        prob_m = 1.0 / D
    dec = dec.copy()
    for d in range(D):
        if np.random.rand() < prob_m:
            u = np.random.rand()
            if u <= 0.5:
                delta = ( (2 * u + (1 - 2 * u) * (1 - dec[d]) ** (mu + 1)) ** (1.0 / (mu + 1)) ) - 1.0
                dec[d] += delta
            else:
                delta = 1.0 - ( (2 * (1 - u) + 2 * (u - 0.5) * dec[d] ** (mu + 1)) ** (1.0 / (mu + 1)) )
                dec[d] += delta
    return dec

def generation(population: np.ndarray, mu_c: float = 2, mu_m: float = 5):
    """
    GA solver gốc: nhận population (N,d) -> offspring (N,d).
    """
    N, d = population.shape
    if N <= 1:
        # chỉ có một cá thể: chỉ mutation
        return np.array([ga_mutation(population[0], mu_m) for _ in range(N)])

    indorder = np.random.permutation(N)
    offspring = np.zeros_like(population)
    count = 0
    half = int(np.ceil(N / 2))
    for i in range(half):
        p1 = indorder[i]
        p2 = indorder[i + (N // 2) % N]  # wrap nếu N lẻ
        off1 = population[p1].copy()
        off2 = population[p2].copy()

        # SBX crossover
        off1, off2 = ga_crossover(population[p1], population[p2], mu_c)

        # mutation
        off1 = ga_mutation(off1, mu_m)
        off2 = ga_mutation(off2, mu_m)

        off1 = np.clip(off1, 0.0, 1.0)
        off2 = np.clip(off2, 0.0, 1.0)

        offspring[count] = off1
        if count + 1 < N:
            offspring[count + 1] = off2
        count += 2
    return offspring


No.2 solver’s description and its code:
# Its Description
{The solver uses a hybrid approach combining Gaussian mutation with a local search mechanism to refine promising areas of the search space while ensuring diversity is minimized to promote faster convergence.}
# Its Python Code Implementation of a Function
import numpy as np

def local_search(offspring: np.ndarray, alpha: float):
    """
    Apply a local search to refine the offspring by moving them towards the average
    of neighboring solutions in the population.
    """
    N, D = offspring.shape
    refined_offspring = offspring.copy()
    for i in range(N):
        neighbors = np.delete(offspring, i, axis=0)
        avg_neighbor = np.mean(neighbors, axis=0)
        refined_offspring[i] += alpha * (avg_neighbor - offspring[i])
    return np.clip(refined_offspring, 0.0, 1.0)

def generation(population: np.ndarray, alpha: float = 0.5):
    """
    Fast convergence generation solver: accepts population (N,d) -> offspring (N,d).
    """
    N, d = population.shape
    offspring = np.zeros_like(population)

    # Generate offspring using Gaussian mutation
    for i in range(N):
        # Gaussian mutation with a small step size
        mutation = np.random.normal(loc=0.0, scale=0.1, size=d)
        offspring[i] = np.clip(population[i] + mutation, 0.0, 1.0)

    # Refine offspring through local search
    offspring = local_search(offspring, alpha)

    return offspring


**Poor solvers to avoid:**

No.1 poor solver’s description and its code:
# Its Description
{Differential Evolution (DE) Crossover: This operator generates an offspring population by applying DE/rand/1 mutation and binomial crossover to each individual in the given population.}
# Its Python Code Implementation of a Function
import numpy as np

def de_crossover(off_dec: np.ndarray, par_dec: np.ndarray, CR: float):
    """
    DE_Crossover từ MATLAB gốc:
    thay thế các vị trí theo CR.
    """
    D = off_dec.shape[0]
    replace = np.random.rand(D) > CR
    # luôn giữ ít nhất một gene khác cha
    j_rand = np.random.randint(D)
    replace[j_rand] = False
    off_dec = off_dec.copy()
    off_dec[replace] = par_dec[replace]
    return off_dec

def ga_mutation(dec: np.ndarray, mu: float, prob_m: float = None):
    """
    Polynomial mutation giống GA_Mutation trong MATLAB gốc.
    """
    D = dec.shape[0]
    if prob_m is None:
        prob_m = 1.0 / D
    dec = dec.copy()
    for d in range(D):
        if np.random.rand() < prob_m:
            u = np.random.rand()
            if u <= 0.5:
                delta = ( (2 * u + (1 - 2 * u) * (1 - dec[d]) ** (mu + 1)) ** (1.0 / (mu + 1)) ) - 1.0
                dec[d] += delta
            else:
                delta = 1.0 - ( (2 * (1 - u) + 2 * (u - 0.5) * dec[d] ** (mu + 1)) ** (1.0 / (mu + 1)) )
                dec[d] += delta
    return dec

def generation(population: np.ndarray, F: float = 0.5, CR: float = 0.9, mu_m: float = 15.0):
    """
    DE solver gốc: nhận population (N,d) -> offspring (N,d)
    """
    N, d = population.shape
    offspring = np.zeros_like(population)

    if N < 4:
        # ít hơn 4 thì chỉ mutation như GA
        for i in range(N):
            offspring[i] = ga_mutation(population[i], mu_m)
        return np.clip(offspring, 0.0, 1.0)

    for i in range(N):
        # copy cha mẹ
        # chọn ngẫu nhiên 3 cá thể khác i
        idxs = np.random.choice([idx for idx in range(N) if idx != i], 3, replace=False)
        x1, x2, x3 = population[idxs]

        # mutation: x1 + F*(x2-x3)
        trial = x1 + F * (x2 - x3)

        # crossover với cha hiện tại
        trial = de_crossover(trial, population[i], CR)

        offspring[i] = np.clip(trial, 0.0, 1.0)
    assert(len(offspring) == len(population))
    return offspring


No.2 poor solver’s description and its code:
# Its Description
{Simulated Binary Crossover (SBX) combined with Polynomial Mutation: This operator generates an offspring population by pairing parents from the given population, performing SBX crossover on each pair, and then applying polynomial mutation to introduce additional diversity.}
# Its Python Code Implementation of a Function
import numpy as np

def ga_crossover(par_dec1: np.ndarray, par_dec2: np.ndarray, mu: float):
    """
    SBX crossover giống GA_Crossover trong MATLAB gốc.
    """
    D = par_dec1.shape[0]
    u = np.random.rand(D)
    beta = np.zeros(D)
    beta[u <= 0.5] = (2 * u[u <= 0.5]) ** (1.0 / (mu + 1))
    beta[u > 0.5] = (2 * (1 - u[u > 0.5])) ** (-1.0 / (mu + 1))

    # flip sign randomly
    beta = beta * ((-1) ** np.random.randint(0, 2, size=D))
    beta[np.random.rand(D) < 0.5] = 1.0

    off1 = 0.5 * ((1 + beta) * par_dec1 + (1 - beta) * par_dec2)
    off2 = 0.5 * ((1 + beta) * par_dec2 + (1 - beta) * par_dec1)
    return off1, off2

def ga_mutation(dec: np.ndarray, mu: float, prob_m: float = None):
    """
    Polynomial mutation giống GA_Mutation trong MATLAB gốc.
    """
    D = dec.shape[0]
    if prob_m is None:
        prob_m = 1.0 / D
    dec = dec.copy()
    for d in range(D):
        if np.random.rand() < prob_m:
            u = np.random.rand()
            if u <= 0.5:
                delta = ( (2 * u + (1 - 2 * u) * (1 - dec[d]) ** (mu + 1)) ** (1.0 / (mu + 1)) ) - 1.0
                dec[d] += delta
            else:
                delta = 1.0 - ( (2 * (1 - u) + 2 * (u - 0.5) * dec[d] ** (mu + 1)) ** (1.0 / (mu + 1)) )
                dec[d] += delta
    return dec

def generation(population: np.ndarray, mu_c: float = 2, mu_m: float = 5):
    """
    GA solver gốc: nhận population (N,d) -> offspring (N,d).
    """
    N, d = population.shape
    if N <= 1:
        # chỉ có một cá thể: chỉ mutation
        return np.array([ga_mutation(population[0], mu_m) for _ in range(N)])

    indorder = np.random.permutation(N)
    offspring = np.zeros_like(population)
    count = 0
    half = int(np.ceil(N / 2))
    for i in range(half):
        p1 = indorder[i]
        p2 = indorder[i + (N // 2) % N]  # wrap nếu N lẻ
        off1 = population[p1].copy()
        off2 = population[p2].copy()

        # SBX crossover
        off1, off2 = ga_crossover(population[p1], population[p2], mu_c)

        # mutation
        off1 = ga_mutation(off1, mu_m)
        off2 = ga_mutation(off2, mu_m)

        off1 = np.clip(off1, 0.0, 1.0)
        off2 = np.clip(off2, 0.0, 1.0)

        offspring[count] = off1
        if count + 1 < N:
            offspring[count + 1] = off2
        count += 2
    return offspring



Please create a new generation solver that strongly focuses on exploitation (fast convergence), refining promising regions and reducing diversity while avoiding premature stagnation.

First, describe the design idea and main steps of your solver in one sentence.
The description must be inside a brace outside the code implementation.
Next, implement it in Python as a function named `generation`.
This function should accept only 1 input: `population`, an array of shape (N, d) of real-valued vectors.
The function should return 1 output: `offspring`, an array of shape (N, d) of real-valued vectors.
The offspring must stay within the bounds [0, 1] for each variable.

Do not give additional explanations.