I am solving optimization problems using evolutionary algorithms.
The goal is to design generation solvers that take a population of parent solutions and produce an offspring population.

I have a list of well-performing solvers with their descriptions and Python code implementations as follows:

**Good solvers:**

No.1 solver’s description and its code:
# Its Description
{Simulated Binary Crossover (SBX) combined with Polynomial Mutation: This operator generates an offspring population by pairing parents from the given population, performing SBX crossover on each pair, and then applying polynomial mutation to introduce additional diversity.}
# Its Python Code Implementation of a Function
import numpy as np

def ga_crossover(par_dec1: np.ndarray, par_dec2: np.ndarray, mu: float):
    """
    SBX crossover giống GA_Crossover trong MATLAB gốc.
    """
    D = par_dec1.shape[0]
    u = np.random.rand(D)
    beta = np.zeros(D)
    beta[u <= 0.5] = (2 * u[u <= 0.5]) ** (1.0 / (mu + 1))
    beta[u > 0.5] = (2 * (1 - u[u > 0.5])) ** (-1.0 / (mu + 1))

    # flip sign randomly
    beta = beta * ((-1) ** np.random.randint(0, 2, size=D))
    beta[np.random.rand(D) < 0.5] = 1.0

    off1 = 0.5 * ((1 + beta) * par_dec1 + (1 - beta) * par_dec2)
    off2 = 0.5 * ((1 + beta) * par_dec2 + (1 - beta) * par_dec1)
    return off1, off2

def ga_mutation(dec: np.ndarray, mu: float, prob_m: float = None):
    """
    Polynomial mutation giống GA_Mutation trong MATLAB gốc.
    """
    D = dec.shape[0]
    if prob_m is None:
        prob_m = 1.0 / D
    dec = dec.copy()
    for d in range(D):
        if np.random.rand() < prob_m:
            u = np.random.rand()
            if u <= 0.5:
                delta = ( (2 * u + (1 - 2 * u) * (1 - dec[d]) ** (mu + 1)) ** (1.0 / (mu + 1)) ) - 1.0
                dec[d] += delta
            else:
                delta = 1.0 - ( (2 * (1 - u) + 2 * (u - 0.5) * dec[d] ** (mu + 1)) ** (1.0 / (mu + 1)) )
                dec[d] += delta
    return dec

def generation(population: np.ndarray, mu_c: float = 2, mu_m: float = 5):
    """
    GA solver gốc: nhận population (N,d) -> offspring (N,d).
    """
    N, d = population.shape
    if N <= 1:
        # chỉ có một cá thể: chỉ mutation
        return np.array([ga_mutation(population[0], mu_m) for _ in range(N)])

    indorder = np.random.permutation(N)
    offspring = np.zeros_like(population)
    count = 0
    half = int(np.ceil(N / 2))
    for i in range(half):
        p1 = indorder[i]
        p2 = indorder[i + (N // 2) % N]  # wrap nếu N lẻ
        off1 = population[p1].copy()
        off2 = population[p2].copy()

        # SBX crossover
        off1, off2 = ga_crossover(population[p1], population[p2], mu_c)

        # mutation
        off1 = ga_mutation(off1, mu_m)
        off2 = ga_mutation(off2, mu_m)

        off1 = np.clip(off1, 0.0, 1.0)
        off2 = np.clip(off2, 0.0, 1.0)

        offspring[count] = off1
        if count + 1 < N:
            offspring[count + 1] = off2
        count += 2
    return offspring



**Poor solvers to avoid:**

No.1 poor solver’s description and its code:
# Its Description
{Differential Evolution (DE) Crossover: This operator generates an offspring population by applying DE/rand/1 mutation and binomial crossover to each individual in the given population.}
# Its Python Code Implementation of a Function
import numpy as np

def de_crossover(off_dec: np.ndarray, par_dec: np.ndarray, CR: float):
    """
    DE_Crossover từ MATLAB gốc:
    thay thế các vị trí theo CR.
    """
    D = off_dec.shape[0]
    replace = np.random.rand(D) > CR
    # luôn giữ ít nhất một gene khác cha
    j_rand = np.random.randint(D)
    replace[j_rand] = False
    off_dec = off_dec.copy()
    off_dec[replace] = par_dec[replace]
    return off_dec

def ga_mutation(dec: np.ndarray, mu: float, prob_m: float = None):
    """
    Polynomial mutation giống GA_Mutation trong MATLAB gốc.
    """
    D = dec.shape[0]
    if prob_m is None:
        prob_m = 1.0 / D
    dec = dec.copy()
    for d in range(D):
        if np.random.rand() < prob_m:
            u = np.random.rand()
            if u <= 0.5:
                delta = ( (2 * u + (1 - 2 * u) * (1 - dec[d]) ** (mu + 1)) ** (1.0 / (mu + 1)) ) - 1.0
                dec[d] += delta
            else:
                delta = 1.0 - ( (2 * (1 - u) + 2 * (u - 0.5) * dec[d] ** (mu + 1)) ** (1.0 / (mu + 1)) )
                dec[d] += delta
    return dec

def generation(population: np.ndarray, F: float = 0.5, CR: float = 0.9, mu_m: float = 15.0):
    """
    DE solver gốc: nhận population (N,d) -> offspring (N,d)
    """
    N, d = population.shape
    offspring = np.zeros_like(population)

    if N < 4:
        # ít hơn 4 thì chỉ mutation như GA
        for i in range(N):
            offspring[i] = ga_mutation(population[i], mu_m)
        return np.clip(offspring, 0.0, 1.0)

    for i in range(N):
        # copy cha mẹ
        # chọn ngẫu nhiên 3 cá thể khác i
        idxs = np.random.choice([idx for idx in range(N) if idx != i], 3, replace=False)
        x1, x2, x3 = population[idxs]

        # mutation: x1 + F*(x2-x3)
        trial = x1 + F * (x2 - x3)

        # crossover với cha hiện tại
        trial = de_crossover(trial, population[i], CR)

        offspring[i] = np.clip(trial, 0.0, 1.0)
    assert(len(offspring) == len(population))
    return offspring


No.2 poor solver’s description and its code:
# Its Description
{This solver uses a combination of simulated binary crossover (SBX) and adaptive mutation, where the probability of mutation is dynamically adjusted based on the diversity of the population, to encourage both exploration and exploitation for improved offspring generation.}
# Its Python Code Implementation of a Function
import numpy as np

def ga_crossover(par_dec1: np.ndarray, par_dec2: np.ndarray, mu: float):
    D = par_dec1.shape[0]
    u = np.random.rand(D)
    beta = np.zeros(D)
    beta[u <= 0.5] = (2 * u[u <= 0.5]) ** (1.0 / (mu + 1))
    beta[u > 0.5] = (2 * (1 - u[u > 0.5])) ** (-1.0 / (mu + 1))
    beta = beta * ((-1) ** np.random.randint(0, 2, size=D))
    beta[np.random.rand(D) < 0.5] = 1.0
    off1 = 0.5 * ((1 + beta) * par_dec1 + (1 - beta) * par_dec2)
    off2 = 0.5 * ((1 + beta) * par_dec2 + (1 - beta) * par_dec1)
    return off1, off2

def adaptive_mutation(dec: np.ndarray, mu: float, prob_m: float):
    D = dec.shape[0]
    dec = dec.copy()
    for d in range(D):
        if np.random.rand() < prob_m:
            u = np.random.rand()
            if u <= 0.5:
                delta = ((2 * u + (1 - 2 * u) * (1 - dec[d]) ** (mu + 1)) ** (1.0 / (mu + 1))) - 1.0
                dec[d] += delta
            else:
                delta = 1.0 - ((2 * (1 - u) + 2 * (u - 0.5) * dec[d] ** (mu + 1)) ** (1.0 / (mu + 1)))
                dec[d] += delta
    return dec

def generation(population: np.ndarray, mu_c: float = 2, mu_m: float = 5):
    N, d = population.shape
    offspring = np.zeros_like(population)
    
    diversity = np.std(population, axis=0)
    prob_m = np.clip(np.mean(diversity) * 2, 0.01, 1.0)  # Adaptive mutation probability
    
    if N <= 1:
        return np.array([adaptive_mutation(population[0], mu_m, prob_m) for _ in range(N)])

    indorder = np.random.permutation(N)
    count = 0
    half = int(np.ceil(N / 2))
    
    for i in range(half):
        p1 = indorder[i]
        p2 = indorder[i + (N // 2) % N]  # wrap if N odd
        off1, off2 = ga_crossover(population[p1], population[p2], mu_c)
        
        off1 = adaptive_mutation(off1, mu_m, prob_m)
        off2 = adaptive_mutation(off2, mu_m, prob_m)

        offspring[count] = np.clip(off1, 0.0, 1.0)
        if count + 1 < N:
            offspring[count + 1] = np.clip(off2, 0.0, 1.0)
        count += 2
    
    return offspring

No.3 poor solver’s description and its code:
# Its Description
{This solver employs a Hybrid Adaptive Crossover and Mutation strategy that utilizes adaptive crossover rates based on population diversity and integrates both simulated binary crossover and Gaussian mutation to optimize exploration and exploitation balance.}
# Its Python Code Implementation of a Function
import numpy as np

def ga_crossover(par_dec1: np.ndarray, par_dec2: np.ndarray, mu: float):
    D = par_dec1.shape[0]
    u = np.random.rand(D)
    beta = np.zeros(D)
    beta[u <= 0.5] = (2 * u[u <= 0.5]) ** (1.0 / (mu + 1))
    beta[u > 0.5] = (2 * (1 - u[u > 0.5])) ** (-1.0 / (mu + 1))
    beta = beta * ((-1) ** np.random.randint(0, 2, size=D))
    beta[np.random.rand(D) < 0.5] = 1.0
    off1 = 0.5 * ((1 + beta) * par_dec1 + (1 - beta) * par_dec2)
    off2 = 0.5 * ((1 + beta) * par_dec2 + (1 - beta) * par_dec1)
    return off1, off2

def gaussian_mutation(dec: np.ndarray, mu: float, sigma: float):
    D = dec.shape[0]
    dec = dec.copy()
    mutation = np.random.normal(0, sigma, D)
    dec += mutation
    return dec

def generation(population: np.ndarray, mu_c: float = 2, mu_m: float = 0.1):
    N, d = population.shape
    offspring = np.zeros_like(population)

    diversity = np.std(population, axis=0)
    mean_diversity = np.mean(diversity)
    adaptive_sigma = np.clip(mean_diversity, 0.01, 0.2)  # Adaptive standard deviation for mutation

    if N <= 1:
        return np.array([gaussian_mutation(population[0], mu_m, adaptive_sigma) for _ in range(N)])

    indorder = np.random.permutation(N)
    count = 0
    half = int(np.ceil(N / 2))

    for i in range(half):
        p1 = indorder[i]
        p2 = indorder[i + (N // 2) % N]  # wrap if N odd
        off1, off2 = ga_crossover(population[p1], population[p2], mu_c)

        off1 = gaussian_mutation(off1, mu_m, adaptive_sigma)
        off2 = gaussian_mutation(off2, mu_m, adaptive_sigma)

        offspring[count] = np.clip(off1, 0.0, 1.0)
        if count + 1 < N:
            offspring[count + 1] = np.clip(off2, 0.0, 1.0)
        count += 2

    return offspring

No.4 poor solver’s description and its code:
# Its Description
{The new generation solver employs a combination of Simulated Binary Crossover (SBX) and a dynamic Gaussian mutation to adaptively encourage both diversity and convergence towards optimal solutions.}
# Its Python Code Implementation of a Function
import numpy as np

def ga_crossover(par_dec1: np.ndarray, par_dec2: np.ndarray, mu: float):
    D = par_dec1.shape[0]
    u = np.random.rand(D)
    beta = np.zeros(D)
    beta[u <= 0.5] = (2 * u[u <= 0.5]) ** (1.0 / (mu + 1))
    beta[u > 0.5] = (2 * (1 - u[u > 0.5])) ** (-1.0 / (mu + 1))
    beta = beta * ((-1) ** np.random.randint(0, 2, size=D))
    beta[np.random.rand(D) < 0.5] = 1.0
    off1 = 0.5 * ((1 + beta) * par_dec1 + (1 - beta) * par_dec2)
    off2 = 0.5 * ((1 + beta) * par_dec2 + (1 - beta) * par_dec1)
    return off1, off2

def gaussian_mutation(dec: np.ndarray, mean: float, sigma: float):
    D = dec.shape[0]
    dec = dec.copy()
    mutation = np.random.normal(mean, sigma, D)
    dec += mutation
    return dec

def generation(population: np.ndarray, mu_c: float = 2, mu_m: float = 0.1):
    N, d = population.shape
    offspring = np.zeros_like(population)

    diversity = np.std(population, axis=0)
    mean_diversity = np.mean(diversity)
    adaptive_sigma = np.clip(mean_diversity, 0.01, 0.2)  # Adaptive standard deviation for mutation
    adaptive_mean = np.clip(np.mean(population), 0.5, 0.5)  # Center for exploration

    if N <= 1:
        return np.array([gaussian_mutation(population[0], adaptive_mean, adaptive_sigma) for _ in range(N)])

    indorder = np.random.permutation(N)
    count = 0
    half = int(np.ceil(N / 2))

    for i in range(half):
        p1 = indorder[i]
        p2 = indorder[i + (N // 2) % N]  # wrap if N odd
        off1, off2 = ga_crossover(population[p1], population[p2], mu_c)

        off1 = gaussian_mutation(off1, adaptive_mean, adaptive_sigma)
        off2 = gaussian_mutation(off2, adaptive_mean, adaptive_sigma)

        offspring[count] = np.clip(off1, 0.0, 1.0)
        if count + 1 < N:
            offspring[count + 1] = np.clip(off2, 0.0, 1.0)
        count += 2

    return offspring


Please create a new generation solver that balances exploitation and exploration to achieve stable progress and maintain diversity.

First, describe the design idea and main steps of your solver in one sentence.
The description must be inside a brace outside the code implementation.
Next, implement it in Python as a function named `generation`.
This function should accept only 1 input: `population`, an array of shape (N, d) of real-valued vectors.
The function should return 1 output: `offspring`, an array of shape (N, d) of real-valued vectors.
The offspring must stay within the bounds [0, 1] for each variable.

Do not give additional explanations.