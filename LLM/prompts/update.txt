I am solving optimization problems using evolutionary algorithms.
The goal is to design generation solvers that take a population of parent solutions and produce an offspring population.

I have a list of well-performing solvers with their descriptions and Python code implementations as follows:

**Good solvers:**

No.1 solver’s description and its code:
# Its Description
{A novel Family-based Crossover and Mutation operator that combines the concepts of neighbor-based exploration with a multi-parent approach, where each offspring is created by averaging contributions from multiple parents selected from the population, followed by an adaptive mutation step based on the distance of selected parents.}
# Its Python Code Implementation of a Function
import numpy as np

def generation(population):
    N, d = population.shape
    offspring = np.zeros_like(population)

    for i in range(N):
        # Select parents based on random neighbors, with one static reference for diversity
        indices = np.random.choice(N, 4, replace=False)
        p1, p2, p3, reference = population[indices]
        
        # Family-based crossover: average contributions
        child = (p1 + p2 + p3) / 3
        
        # Adaptive mutation based on distance from reference
        mutation_strength = np.linalg.norm(child - reference) / np.sqrt(d)
        for j in range(d):
            if np.random.rand() < 1.0 / (1 + mutation_strength):
                delta = np.random.uniform(-0.1, 0.1)
                child[j] += delta

        # Clip the values to remain in [0, 1]
        offspring[i] = np.clip(child, 0.0, 1.0)
    
    return offspring

No.2 solver’s description and its code:
# Its Description
{A novel Family-based Crossover and Mutation operator that combines the concepts of neighbor-based exploration with a multi-parent approach, where each offspring is created by averaging contributions from multiple parents selected from the population, followed by an adaptive mutation step based on the distance of selected parents.}
# Its Python Code Implementation of a Function
import numpy as np

def generation(population):
    N, d = population.shape
    offspring = np.zeros_like(population)

    for i in range(N):
        # Select parents based on random neighbors, with one static reference for diversity
        indices = np.random.choice(N, 4, replace=False)
        p1, p2, p3, reference = population[indices]
        
        # Family-based crossover: average contributions
        child = (p1 + p2 + p3) / 3
        
        # Adaptive mutation based on distance from reference
        mutation_strength = np.linalg.norm(child - reference) / np.sqrt(d)
        for j in range(d):
            if np.random.rand() < 1.0 / (1 + mutation_strength):
                delta = np.random.uniform(-0.1, 0.1)
                child[j] += delta

        # Clip the values to remain in [0, 1]
        offspring[i] = np.clip(child, 0.0, 1.0)
    
    return offspring


**Poor solvers to avoid:**

No.1 poor solver’s description and its code:
# Its Description
{Differential Evolution (DE) Crossover: This operator generates an offspring population by applying DE/rand/1 mutation and binomial crossover to each individual in the given population.}
# Its Python Code Implementation of a Function
import numpy as np
def generation(population, F=0.5, CR=0.9):
    N, d = population.shape
    offspring = np.zeros_like(population)

    for i in range(N):
        idxs = np.random.choice([idx for idx in range(N) if idx != i], 3, replace=False)
        x1, x2, x3 = population[idxs]
        trial = population[i].copy()
        j_rand = np.random.randint(d)
        for j in range(d):
            if np.random.rand() < CR or j == j_rand:
                trial[j] = x1[j] + F * (x2[j] - x3[j])
        offspring[i] = np.clip(trial, 0.0, 1.0)
    return offspring

No.2 poor solver’s description and its code:
# Its Description
{Differential Evolution (DE) Crossover: This operator generates an offspring population by applying DE/rand/1 mutation and binomial crossover to each individual in the given population.}
# Its Python Code Implementation of a Function
import numpy as np
def generation(population, F=0.5, CR=0.9):
    N, d = population.shape
    offspring = np.zeros_like(population)

    for i in range(N):
        idxs = np.random.choice([idx for idx in range(N) if idx != i], 3, replace=False)
        x1, x2, x3 = population[idxs]
        trial = population[i].copy()
        j_rand = np.random.randint(d)
        for j in range(d):
            if np.random.rand() < CR or j == j_rand:
                trial[j] = x1[j] + F * (x2[j] - x3[j])
        offspring[i] = np.clip(trial, 0.0, 1.0)
    return offspring


Please create a new generation solver that takes inspiration from the well-performing solvers but avoids the weaknesses and design patterns of the poor-performing solvers.
The new solver should aim for strong performance on optimization tasks.
First, describe the design idea and main steps of your solver in one sentence.
The description must be inside a brace outside the code implementation.
Next, implement it in Python as a function named `generation`.
This function should accept only 1 input: `population`, an array of shape (N, d) of real-valued vectors.
The function should return 1 output: `offspring`, an array of shape (N, d) of real-valued vectors.
The offspring must stay within the bounds [0, 1] for each variable.

Do not give additional explanations.